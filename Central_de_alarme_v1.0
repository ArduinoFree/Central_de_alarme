#include <SPI.h>
#include <Ethernet.h>

/*
 * Projeto: Central de Alarme v1.1
 * Nome: Guilherme Spadaccia 
 * Data: 20/02/2014
 * Utilizados fontes de: PAUL BADGER, 2008; JACQUES DANIEL MORESCO, 2012; David A. Mellis, 2009; 
 * Fonte criado para ser utilizado com o Arduino Uno R3 para montagem de uma central de alarme.
 */

//variaveis usadas no leitor de RF
int x,startbit,ctr,dataok,t1,larpulso,larpulso1,larpulso2,larpulso3,larpulso4,bt1,bt2,antcode=0;
unsigned long _data=0;   // DATA é o Código recebio do HT6p20 todos os 28 BITS onde, 22 do coodigo+2 dos botões+4 do anti-codigo;
unsigned long _dur,_dur1;      // Duração do Pulso
unsigned long bkpTempo1;
unsigned long bkpTempo2;
byte          _pin;    // Pino que vai receber o sinal RF digital.
byte _compar1[] = {1,0,1,0,1,1,1,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0};
byte _compar2[] = {1,0,1,0,1,1,0,1,0,0,1,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,1,0};
boolean ret = false;
int botao1 = 3;  
int botao2 = 4;
boolean stat = false;
int numMax = 0;
//long intervalo1 = 60000;
long intervalo1 = 10000;
long intervalo2 = 5000;
int rele = 9;
//Ethernet Shield
byte mac[] = { 
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192,168,0, 8);
EthernetServer server(80);
EthernetClient client;


void setup()                    
{
  pinMode(botao1, INPUT);
  digitalWrite(botao1,LOW);
  pinMode(botao2, INPUT);
  digitalWrite(botao2,LOW);
  _pin=8;
  Serial.begin(9600);
  pinMode(_pin, INPUT);
  pinMode(13, OUTPUT);
  pinMode(rele,OUTPUT);
  digitalWrite(13,LOW);
  // start the Ethernet connection and the server:
  Ethernet.begin(mac, ip);
  server.begin();
  Serial.print("server is at ");
  Serial.println(Ethernet.localIP());
}

void loop()                    
{
  client = server.available();
  LeTeclado();
  LeWebServer();
  if (stat){
    if(millis()-bkpTempo1 > intervalo1){
        if (LeSensor()){
          if(millis()-bkpTempo2 > intervalo2){
            digitalWrite(rele,HIGH);
          }
        }
    }
  }
}

boolean LeWebServer(){
 if (client) {
    Serial.println("new client");
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    String buffer = "";
    
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        buffer += c;
        //Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the http request has ended,
        // so you can send a reply
        if (c == '\n' && currentLineIsBlank) {
          // send a standard http response header
          client.println("HTTP/1.1 200 OK");
          client.println("Content-Type: text/html");
          client.println("Connnection: close");
          client.println();
          client.println("<!DOCTYPE HTML>");
          client.println("<html>");
                    // add a meta refresh tag, so the browser pulls again every 5 seconds:
          client.println("<meta http-equiv=\"refresh\" content=\"5; http://192.168.0.8/\">");
          // output the value of each analog input pin
          
          client.print("<FORM action=\"http://192.168.0.8/\" >");
          
          if (!stat){
            server.print("<a href='?Activate=on'><button style='background-color: #ffffff; border: 2px solid #000000;' type='button'>Ativar alarme</button></a><br/>");
          }else{
            server.print("<a href='?Activate=off'><button style='background-color: #ffffff; border: 2px solid #000000;' type='button'>Desativar alarme</button></a><br/>");
          }
          /*server.print("<a href='?Sirene=on'><button style='background-color: #ffffff; border: 2px solid #000000;' type='button'>Ligar Sirene</button></a><br/>");
          server.print("<a href='?Sirene=off'><button style='background-color: #ffffff; border: 2px solid #000000;' type='button'>Desligar Sirene</button></a><br/>");*/
          
          client.println("<br />");
          client.println("</html>");
          break;
        }
        
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } 
        else if (c == '\r' ) {
          // you've gotten a character on the current line
          if(buffer.indexOf("GET /?Activate=on")>=0 && !stat){
            //digitalWrite(8,HIGH);  // 5<--- Catch ON status and set LED
            Serial.println("alarme ativado");
            digitalWrite(rele,HIGH);
            delay(200);
            digitalWrite(rele,LOW);
            stat = true;
            ret = false;
            bkpTempo1 = millis();
          }
          else if(buffer.indexOf("GET /?Activate=off")>=0 && stat){
            Serial.println("alarme desativado");
            digitalWrite(rele,LOW);
            delay(200);
            digitalWrite(rele,HIGH);
            delay(200);
            digitalWrite(rele,LOW);
            delay(200);
            digitalWrite(rele,HIGH);
            delay(200);
            digitalWrite(rele,LOW);
            stat = false;
            ret = true;
          }
          /*else if(buffer.indexOf("GET /?Sirene=on")>=0 && control != 3){
            Serial.println("sirene ativada");
            digitalWrite(AtivaSirene, HIGH);
            control = 3;
          }
          else if(buffer.indexOf("GET /?Sirene=off")>=0 && control != 4){
            Serial.println("sirene desativada");
            digitalWrite(AtivaSirene, LOW);
            control = 4;
          }*/
        }else{
            currentLineIsBlank = false;
          }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
    Serial.println("client disonnected");
  }
  return(stat);
}

//funcao que le o teclado e a ethernet shield
boolean LeTeclado(){
  if (!stat){  
    if(digitalRead(botao1) == HIGH){
      digitalWrite(rele,HIGH);
      delay(200);
      digitalWrite(rele,LOW);
      stat = true;
      ret = false;
      bkpTempo1 = millis();
    }
  }else{
    if(digitalRead(botao2) == HIGH){
      digitalWrite(rele,LOW);
      delay(200);
      digitalWrite(rele,HIGH);
      delay(200);
      digitalWrite(rele,LOW);
      delay(200);
      digitalWrite(rele,HIGH);
      delay(200);
      digitalWrite(rele,LOW);
      stat = false;
      ret = true;
    } 
  }
  return(stat);
}

boolean LeSensor(){
  byte bytes;
  char myChar;
  if (!ret){ 
  digitalWrite(13, digitalRead(_pin)); //Pisca o LED conforme o valor da entrada digital, testar interferencias.
  if (startbit==0)
  {// Testa o tempo piloto até o Bit de inicio;
    _dur = pulseIn(_pin, LOW);
    if(_dur > 8000 && _dur < 12000 && startbit==0)
    {
      larpulso=_dur/23;
      larpulso1=larpulso-50;
      larpulso2=larpulso+50;
      larpulso3=larpulso+larpulso-50;
      larpulso4=larpulso+larpulso+50;
      startbit=1;

      _dur=0;
      _data=0;
      dataok=0;
      ctr=0;
    }
  }

  // Se o Bit de inicio OK ENTÃO Inicia a medição do tempo em Nivel ALTO dos sinais, e testa se o tempo está na faixa.
  if (startbit==1 && dataok==0 && ctr < 28)
  {
    ++ctr;
    _dur1 = pulseIn(_pin, HIGH);
    if(_dur1 > larpulso1 && _dur1 < larpulso2)     // Se a largura de pulso é entre 1/4000 e 1/3000 segundos
    {
      _data = (_data << 1) + 1;      // anexar um * 1 * para a extremidade mais à direita do buffer
    }
    else if(_dur1 > larpulso3 && _dur1 < larpulso4)   // Se a largura de pulso é entre 2/4000 e 2/3000 segundos
    {
      _data = (_data << 1);       // anexar um * 0 * para a extremidade mais à direita do buffer
    }
    else
    {
      /* força finalização do laço */
      startbit=0;
    }
  }
  if (ctr==28)
  { 
    if (bitRead(_data,0)==1)
    { 
      if (bitRead(_data,1)==0)
      {
        if (bitRead(_data,2)==1)
        {
          if (bitRead(_data,3)==0)
          {
            antcode=1;
          }
        }
      }
    }
    if (antcode==1)
    {// Se foram recebidos todos os 28 Bits, o valor vai para a variavel _data e pode ser usada como exemplo abaixo.
      dataok=1;
      Serial.println(_data,BIN);
      
      //Este código comentado le o código de um sensor
      /*for(int i=0; i<29;i++){
        if (bitRead(_data,i) == _compar1[i]){
          Serial.print(bitRead(_data,i),BIN);
          Serial.print(" - ");
          Serial.println(_compar1[i],BIN);
        }else{
          Serial.print(bitRead(_data,i),BIN);
          Serial.print(" - ");
          Serial.println(_compar1[i],BIN);
        }
      }*/
      
      for(int i=0; i<29;i++){
        if (bitRead(_data,i) == _compar1[i]){
          ret = true;
        }else{
          ret = false;
          break;
        }
      }
      if(!ret){
        for(int i=0; i<29;i++){
          if (bitRead(_data,i) == _compar2[i]){
            ret = true;
          }else{
            ret = false;
            break;
          }
        }
      }
      if(ret){
        bkpTempo2 = millis();
      }
      ctr=0;
      startbit=0;
      antcode=0;
      delay(100);
    }
  } 
  }
  return(ret);
}
